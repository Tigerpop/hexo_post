---
layout: posts
title: "9-btc匿名性"
date: 2025-01-10 21:11:11
description: "这是文章开头，显示在主页面，详情请点击此处。"
categories: 
- "区块链"
tags:
- "btc"



---

简介 <!--more-->



# 关联性

![截屏2024-12-03 20.47.27](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2020.47.27.png)

推测，输入输出脚本中，可能包括 同一个人的找零的地址，因为不一定 总是整数。



在一笔打包好的交易中，如下，addr4 就是 找零的地址。

![截屏2024-12-03 20.54.56](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2020.54.56.png)

> 把常用的btc钱包的 生成交易的方式搞清楚，链上的很大一批的转账交易都能被分析出来。



一个人可以生产很多的地址账户，但是这些地址账户是可以通过转账分析被关联起来的，一旦和实体关联就可能暴露个人信息。

也就是说，btc账户之间可能被关联，btc账户和实体也可能被关联。

简单说，btc链的匿名性并不好。



![截屏2024-12-03 21.29.23](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2021.29.23.png)

btc链其实是在应用层上的，传输是在网络层中完成的，而网络层中的 匿名性是可以通过tor 这样 “多路径转发”的方式来实现，



# coin mixing

混币，来实现不知道这个币是从哪里来的。前提是混币交易所不能泄漏客户充钱和提币记录。

但是 coin mixing 的服务商本身也是匿名的，它要是跑路，没有办法追回 了。



区块链的不可篡改性 对 匿名性其实 是 灾难性的。



# 零知识证明

![截屏2024-12-03 21.46.25](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2021.46.25.png)



# 同态隐藏

![截屏2024-12-03 21.49.32](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2021.49.32.png)

同态隐藏是 零知识证明的 数学基础；

1、不碰撞；2、 难反推；3、同态加法和同态乘法（关键）。

![截屏2024-12-03 21.58.10](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2021.58.10.png)

![截屏2024-12-03 21.58.47](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-03%2021.58.47.png)



# 盲签方法

前提例子：央行发行货币，搞一个UTXO 来记录没花的钱，避免双花，但是央行知道你的所有信息，为了避免银行知道你的所有交易信息， 为了让央行做中心化的记账，又不想让他知道你的交易，就用到了盲签的方法；

货币的编号 不能由央行产生，而是消费者产生的。

![截屏2024-12-09 20.18.29](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-09%2020.18.29.png)

我不解释一下 很多人可能看不懂 上面例子的意思：

以下是改进的版本，补充了关键步骤，确保逻辑清晰：

一、**A 申请盲签**

1. A 准备一笔金额（例如：100金额），生成一个随机编号 `serialnum`，并对“100金额+serialnum”加密（通过某种盲化算法，记为 `Blind(100, serialnum)`）。
2. A 将盲化后的信息 `Blind(100, serialnum)` 提交给央行，请求签名。

二、**央行盲签**

1. 央行检查A的账户余额，确认是否有足够的存款（A的账户余额 >= 100）。
2. 如果余额足够，央行对盲化信息 `Blind(100, serialnum)` 进行签名，生成签名后的盲化数据 `SignedBlind(100, serialnum)`，返回给A。
3. 同时，央行在账本中减少A的存款 100金额。

三、**A 解盲**

1. A 接收到央行的签名后，使用解盲算法移除盲化掩码，得到签名后的原始信息 `Signed(100, serialnum)`（即明文金额和编号的签名）。
2. A 将 `Signed(100, serialnum)` 和明文金额 `100, serialnum` 交给交易对象B。

四、**B 收款并验证**

1. B 收到 A 提供的 `Signed(100, serialnum)` 和明文金额 `100, serialnum`。
2. B 使用央行的公钥验证签名是否有效：检查 `Signed(100, serialnum)` 是否匹配明文 `100, serialnum`。
3. 验证通过后，B 将 `100, serialnum` 和 `Signed(100, serialnum)` 提交给央行。

五、**央行确认并增款**

1. 央行收到 B 提交的信息后，使用公钥验证 `Signed(100, serialnum)` 的有效性。
2. 确认签名有效后，将 100金额记入B的账户。
3. 央行只知道这笔交易中用的是编号为 `serialnum` 的签名Token，但不知道它来自谁，无法关联到A。

央行只能看到钱数字，却不能把 钱的编号 买家和卖家联系起来。



# 零币零钞

![截屏2024-12-09 20.53.14](9-btc%E5%8C%BF%E5%90%8D%E6%80%A7/%E6%88%AA%E5%B1%8F2024-12-09%2020.53.14.png)

这样的匿名性的 币，打断了 交易的联系，需要 强的 随机源，而且数字货币变现的时候依然 可能被关联不一定有 绝对匿名性。还要当心加密交易所跑路。





